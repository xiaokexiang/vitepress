---
sort: 30
---
# 实战

::: tip
若想实现Sidecar自动注入，需通过`kubectl label namespace <your_namespace> istio-injection=enabled`来开启自动注入。或使用`kubectl apply -f <(istioctl kube-inject -f <yaml>) -n <namespace>`手动注入。
:::

##  对等认证

###  未开启mTLS认证

```bash
$ cat <<EOF> ./sleep.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: sleep
---
apiVersion: v1
kind: Service
metadata:
  name: sleep
  namespace: test
  labels:
    app: sleep
spec:
  ports:
    - port: 80
      name: http
  selector:
    app: sleep
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sleep
spec:
  replicas: 1
  selector:
    matchLabels:
      app: sleep
  template:
    metadata:
      labels:
        app: sleep
    spec:
      terminationGracePeriodSeconds: 0
      serviceAccountName: sleep
      containers:
        - name: sleep
          image: curlimages/curl
          command: ["/bin/sleep", "infinity"]
          imagePullPolicy: IfNotPresent
EOF
$ cat <<EOF> ./httpbin.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: httpbin
---
apiVersion: v1
kind: Service
metadata:
  name: httpbin
  labels:
    app: httpbin
    service: httpbin
spec:
  ports:
    - name: http
      port: 8000
      targetPort: 80
  selector:
    app: httpbin
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: httpbin
spec:
  replicas: 1
  selector:
    matchLabels:
      app: httpbin
      version: v1
  template:
    metadata:
      labels:
        app: httpbin
        version: v1
    spec:
      serviceAccountName: httpbin
      containers:
        - image: docker.io/kong/httpbin
          imagePullPolicy: IfNotPresent
          name: httpbin
          ports:
            - containerPort: 80
EOF
$ kubectl apply -f <(istioctl kube-inject -f ./httpbin.yaml) -n test
$ kubectl apply -f <(istioctl kube-inject -f ./sleep.yaml) -n test
$ kubectl apply -f <(istioctl kube-inject -f ./sleep.yaml)
# 从default下的sleep发起http请求（没有注入envoy代理）
$ kubectl exec -it $(kubectl get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
{
  "origin": "127.0.0.6"
}
# 从test下的sleep发起http请求
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
{
  "origin": "127.0.0.6"
}
```

> - 分别创建没有代理的sleep服务，有代理的sleep服务以及有代理的httpbin服务。两个sleep都能访问httpbin的服务。

###  开启mTLS认证

```bash
$ cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: peer-policy
  namespace: test
spec:
  mtls:
    mode: STRICT
EOF
$ kubectl exec -it $(kubectl get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
curl: (56) Recv failure: Connection reset by peer
command terminated with exit code 56
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
{
  "origin": "127.0.0.6"
}
```

> - 创建`对等认证`规则，匹配namespace: test下的所有服务（因为没有定义selector），策略为`STRICT(所有服务都要求mTLS访问)`。
> - 对等认证开启后，`没有代理的sleep服务无法访问httpbin服务`，而具有代理的sleep服务则可以访问。

##  请求认证

```bash
$ cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1
kind: RequestAuthentication
metadata:
  name: jwt-example
  namespace: istio-system
spec:
  selector:
    matchLabels:
      istio: ingressgateway # 绑定istio的ingressgateway网关
  jwtRules:
    - issuer: "xiaokexiang@aliyun.com" # 指定访问的issuer
      jwks: | # 对应jwt的公钥
        {
          "keys": [
            {
              "alg": "RS256",
              "use": "sig",
              "e": "AQAB",
              "kty": "RSA",
              "n": "32j3q4FvIorhQLSvj4woX_-U-rNTMnWU351L_Cg3Nk2cgIf96fyXQDa31hoJUf6EvHxoaDZq5b93UKfL1cerbOmkWBKjBYwb9LxKvbMJeq6nXBGq3X9tgFrhj4GDY_uthUBpmTQzCNF8pc_JrlsxT7Qz9dukvoVHH8nZrjcEOqlOa3eGQ69IkJVj0Si8tTdRmZ-epIhn71dhBp3mPobTf9eVeVx2Ci0elcuLlJpDylwPfLk-dtkCEgp8Ij5GBbXcRY5K4zo_uVa-TisVSbjF06T62wZQvytMzTr3N3CvgMZsaGzcHTSw9TXXA7DWDHlw7NFo7PJrzTnPLZtuR9ilZQ"
            }
          ]
        }
EOF
# token由jwt工具生成
$ curl --header "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MDQ0MjUzODMsImlzcyI6InhpYW9rZXhpYW5nQGdtYWlsLmNvbSIsInN1YiI6InRlc3Qgand0In0.hF3-hX9p_zKZXLxGwhB-vTBS9K2IhjGLj1b98VDyLjTqk5y3Rsy5TdIzvkP_ma-DH53tvXGOXjd-jn1O3P_91wV3Lgz90dZpw4ha7kRYaafMbkTZgfN986mftXqlz49JujClwLMqkiiMRGQE72HD8SpUCn4LmYxuaETeG1iF1Tz4GHe8eI4om-VqRznclbDU5FxCuDGyCsneU8_ZEaNbv0KLgZwfwwr0HSCvIs4t3QcSqWR7l8hs6MH5d1_ZOiQ3vePhX4kAo7d-eA3xMPfIfj5LQ-PLWuSqB5ToRz1FrbVVa8Fx_AJdsQGOdjq1Ws6kMKyIl65plOPkp4LWrWd8xA" $INGRESS_HOST:$INGRESS_PORT/ip
{
  "origin": "10.244.0.1"
}
```

> - jwks和jwksUri两者只能二选其一，前者表示文本，后者指向一个文本地址。
> - 使用[jwt令牌生成工具](https://github.com/xiaokexiang/jwt-tooos)生成公私钥、令牌和jwks配置，也可以使用[jwt在线令牌验证](https://jwt.io/)来验证令牌是否合法。
>
> ```bash
> # 生成公私钥
> $ ./jwt cert
> # 这个名称就是ra的yaml中指定的名字，不匹配会无法访问
> $ ./jwt enc --iss=xiaokexiang@aliyun.com
> # 生成jwk配置，其实对应着公钥
> $ ./jwt jwk
> ```
>
> - 如果禁止不携带令牌也能访问的情况，需要配置`AuthorizationPolicy`:
>
> ```bash
> $ cat <<EOF | kubectl apply -f -
> apiVersion: security.istio.io/v1
> kind: AuthorizationPolicy
> metadata:
>  name: refuse-without-token
>  namespace: istio-system
> spec:
>  selector:
>    matchLabels:
>      istio: ingressgateway
>  action: DENY
>  rules:
>  - from:
>    - source:
>        notRequestPrincipals: ["*"] # 表示不携带请求主题
>    to:
>    - operation:
>        path: ["/headers"] # header请求不携带token会拒绝访问
>        methods: ["GET"]
> EOF
> $ curl $INGRESS_HOST:$INGRESS_PORT/ip
> {
>   "origin": "10.244.0.1"
> }
> $ curl $INGRESS_HOST:$INGRESS_PORT/headers
> RBAC: access denied
> ```

###  复制JWT声明到HTTP头

```bash
$ cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1
kind: RequestAuthentication
metadata:
  name: "jwt-example"
  namespace: test
spec:
  selector:
    matchLabels:
      app: httpbin # 绑定httpbin服务
  jwtRules:
    - issuer: "xiaokexiang@aliyun.com"
      outputClaimToHeaders:
        - header: "X-Jwt-Claim-Sub" # 输出的请求头key
          claim: "sub" # 值从jwt的payload的sub获取
      jwks: |
        {
          "keys": [
            {
              "alg": "RS256",
              "e": "AQAB",
              "kty": "RSA",
              "n": "xoEooXKh6JNK0KefERE-F8_pGOdFV5bCSqluLSUWeFNEarxSK_WoGjxGbr6qSJOG4RB5xqw7fOutFGGbAh2bDdyjAwZ9d271Ga_9SJCl5_VU4miNYu7VUvqGb_wBhclhRxEOQ7BE1q9YT_HTWJSDzXHFgVM_nULhYaesxhqnfmyybNM3oj30iAXAlY4fc0waQuUlH9YWacp7VByyF-cBvCIyJeU4w_PPBtrbE-67Zjadh1VL7Mvobl7PG50rOKiztVyvaIBV1arc2Jm86Jh5puVPDWd8mtv-Qc-khvtfJ4A-CVl61tmqtDxQDqDYKc8HRyG5X6X7KosNpZTYe-SzoQ",
              "use": "sig"
            }
          ]
        }
EOF
# 发起服务间访问
$ curl -sS -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MDQ0NDA2MDEsImlzcyI6InhpYW9rZXhpYW5nQGFsaXl1bi5jb20iLCJzdWIiOiJ0ZXN0IGp3dCJ9.f_qFd1pmLBqxcWLbE0MSr98UCUebqMuTvgELENPPiDaQ0blxEJRwaXKMVgpzp9GN364IbqJRTBEUVZiXk8gkduVwWtlHTVdm6PSkADgRgk4A31u1nJHFoqoCz-21Vj8zatSCz17YlOeHZYcu8xOk0fqt6M_CzLyyJF5gS-MdjRwoTuK59aTE41goG_7tXrikQ748zSblrOmZ9noCpf_GcvRkS0yQLIz1iWcyZdRtdXkxXjXSBGL976a_OUR6kjurCKSGHTB-0o2LXNXmuxGGfHBoLcdUANv5b6VrLEpxgjHGWXMkZzegNKCtun8SK7I6I73f4qMC15DaUmAGqX7hyA" http://httpbin:8000/headers

{
  "headers": {
    "Accept": "*/*", 
    "Host": "httpbin:8000", 
    "User-Agent": "curl/8.5.0", 
    "X-B3-Parentspanid": "aaacd10302294880", 
    "X-B3-Sampled": "0", 
    "X-B3-Spanid": "58851ef0c8fdb761", 
    "X-B3-Traceid": "74b2866e38744d1baaacd10302294880", 
    "X-Envoy-Attempt-Count": "1", 
    "X-Forwarded-Client-Cert": "By=spiffe://cluster.local/ns/test/sa/httpbin;Hash=63ff1d19edabef26b6f6aed355290fdca82900a64750cc46b0995ad11d549c44;Subject=\"\";URI=spiffe://cluster.local/ns/test/sa/sleep", 
    "X-Jwt-Claim-Sub": "test jwt"
  }
}
```

> sleep向httpbin发起服务间的请求时，httpbin服务接收的请求头中包含`"X-Jwt-Claim-Foo": "test jwt"`。

##  授权

###  HTTP流量

结合上文test下的sleep和httpbin服务，对httpbin服务的访问进行控制。

```bash
# 先开启ns下的mTLS，防止部分参数不起作用
$ cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: peer-policy
  namespace: test
spec:
  mtls:
    mode: STRICT
EOF
# 先默认deny-all
$ cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-nothing
  namespace: test
spec:
  action: ALLOW
EOF
# 同ns的服务间的访问被拒绝   
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
# 跨ns的服务间访问被拒绝
$ kubectl -n default exec -it $(kubectl -n default get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
# 集群内部通过入口网关的流量被拒绝
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl --resolve "httpbin.example.com:30001:10.50.8.88" httpbin.example.com:30001/ip
# 集群外部通过入口网关的流量被拒绝
$ curl --resolve "httpbin.example.com:30001:10.50.8.88" httpbin.example.com:30001/ip
```

- 指定授权策略: 同ns下的sleep服务访问httpbin的ip接口且`携带请求头version：v1`则可以访问

```bash
$ cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-ns-test
  namespace: test
spec:
  selector:
    matchLabels:
      app: httpbin # 绑定test下的httpbin服务
  action: ALLOW
  rules:
    - from:
        - source:
            principals: ["cluster.local/ns/test/sa/sleep"] # 拒绝了跨ns的访问
      to:
        - operation:
            paths: [ "/ip" ] # 拒绝了非ip接口的访问
            methods: [ "GET" ]
      when:
        - key: request.headers[version] # 只有在请求头携带version且值为v1的时候规则才会生效
          values: ["v1"]
EOF
# 同ns服务间的访问不携带请求头被拒绝   
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
# 同ns服务间的访问携带请求头不会被拒绝
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].mleep -- curl -H "version: v1" http://httpbin.test:8000/ip
# 跨ns服务间的访问被拒绝
$ kubectl -n default exec -it $(kubectl -n default get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
# 集群内部通过入口网关的流量被拒绝
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl --resolve "httpbin.example.com:30001:10.50.8.88" httpbin.example.com:30001/ip
# 集群外部通过入口网关的流量被拒绝
$ curl --resolve "httpbin.example.com:30001:10.50.8.88" httpbin.example.com:30001/ip
```

- 指定授权策略：集群外部的流量访问ip需要token验证且只能访问，服务间的访问则没有限制

```bash
# 删除原来的授权条件
$ kubectl -n test delete authorizationpolicy allow-nothing allow-ns-test
$ cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-ingressgateway
  namespace: istio-system
spec:
  selector:
    matchLabels:
      app: istio-ingressgateway # 绑定集群流量入口网关
  action: ALLOW
  rules:
    - from:
        - source:
            notRequestPrincipals: ["*"]
      to:
        - operation:
            paths: [ "/ip" ] # 指定访问接口
            methods: [ "GET" ]
EOF
# 同ns的服务间的访问被拒绝   
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
# 跨ns的服务间访问被拒绝
$ kubectl -n default exec -it $(kubectl -n default get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl http://httpbin.test:8000/ip
# 集群内部通过入口网关的流量被拒绝
$ kubectl -n test exec -it $(kubectl -n test get po -l app=sleep -o jsonpath={.items[0].metadata.name}) -c sleep -- curl --resolve "httpbin.example.com:30001:10.50.8.88" httpbin.example.com:30001/ip
# 集群外部通过入口网关的流量被拒绝
$ curl --resolve "httpbin.example.com:30001:10.50.8.88" httpbin.example.com:30001/ip
```

###  TCP流量





##  TLS多主机网关

###  TLS配置

```bash
$ cat <<EOF > ./istio.yaml
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    meshMTLS:
      minProtocolVersion: TLSV1_3
EOF
$ istioctl install -f ./istio.yaml
```

> 上述步骤会配置最低版本的tls为tls1.3，且istioctl会重新安装profile=default的组件，即ingress-gateway和istiod

###  基于NodePort访问

```bash
# 因为没有外部LoadBalancer，直接使用NodePort访问
# 因为使用Kind，我预先只暴露了30000-30020区间的端口，所以这里需要手动指定下NodePort端口用于集群外部访问（非必要）
$ kubectl -n istio-system patch svc istio-ingressgateway --type='json' -p='[
  {"op":"replace","path":"/spec/ports/1/nodePort","value":30000},
  {"op":"replace","path":"/spec/ports/2/nodePort","value":30003}
]'
# 指定环境变量
$ export INGRESS_NAME=istio-ingressgateway
$ export INGRESS_NS=istio-system
$ export INGRESS_PORT=$(kubectl -n "${INGRESS_NS}" get service "${INGRESS_NAME}" -o jsonpath='{.spec.ports[?(@.name=="http2")].nodePort}')
$ export SECURE_INGRESS_PORT=$(kubectl -n "${INGRESS_NS}" get service "${INGRESS_NAME}" -o jsonpath='{.spec.ports[?(@.name=="https")].nodePort}')
$ export TCP_INGRESS_PORT=$(kubectl -n "${INGRESS_NS}" get service "${INGRESS_NAME}" -o jsonpath='{.spec.ports[?(@.name=="tcp")].nodePort}')
$ export INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n "${INGRESS_NS}" -o jsonpath='{.items[0].status.hostIP}')
```

> 因为Kind是基于docker部署的，所以这里的INGRESS_HOST会输出docker ip，如果集群外部访问，也可以使用节点ip。

###  生成域名证书

```bash
# 生成根证书example.com和私钥
$ mkdir example_certs1
$ openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example_certs1/example.com.key -out example_certs1/example.com.crt

# 生成证书httpbin.example.com和私钥
$ openssl req -out example_certs1/httpbin.example.com.csr -newkey rsa:2048 -nodes -keyout
$ example_certs1/httpbin.example.com.key -subj "/CN=httpbin.example.com/O=httpbin organization"
openssl x509 -req -sha256 -days 365 -CA example_certs1/example.com.crt -CAkey example_certs1/example.com.key -set_serial 0 -in example_certs1/httpbin.example.com.csr -out example_certs1/httpbin.example.com.crt

# 生成证书helloworld.example.com和私钥
$ openssl req -out example_certs1/helloworld.example.com.csr -newkey rsa:2048 -nodes -keyout $ example_certs1/helloworld.example.com.key -subj "/CN=helloworld.example.com/O=helloworld organization"
openssl x509 -req -sha256 -days 365 -CA example_certs1/example.com.crt -CAkey example_certs1/example.com.key -set_serial 1 -in example_certs1/helloworld.example.com.csr -out example_certs1/helloworld.example.com.crt

# 生成客户端client.example.com证书和私钥
$ openssl req -out example_certs1/client.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs1/client.example.com.key -subj "/CN=client.example.com/O=client organization"
$ openssl x509 -req -sha256 -days 365 -CA example_certs1/example.com.crt -CAkey example_certs1/example.com.key -set_serial 1 -in example_certs1/client.example.com.csr -out example_certs1/client.example.com.crt
```

###  生成TLS凭证

```bash
# 供httpbin.example.com使用
$ kubectl create -n istio-system secret tls httpbin-secret \
  --key=example_certs1/httpbin.example.com.key \
  --cert=example_certs1/httpbin.example.com.crt
# 供helloworld.example.com使用
$ kubectl create -n istio-system secret tls helloworld-secret \
  --key=example_certs1/helloworld.example.com.key \
  --cert=example_certs1/helloworld.example.com.crt
```

> gateway的TLS证书可以通过Secret的方式绑定，这里通过命令生成在istio-system命名空间下TLS类型的Secret。

###  配置服务和Service

```bash
# 创建基于httpbin和helloworld的deploy&svc
$ cat <<EOF | kubectl -n test apply -f -
apiVersion: v1
kind: Service
metadata:
  name: httpbin
  labels:
    app: httpbin
spec:
  ports:
    - name: http
      port: 80
      targetPort: 8080
  selector:
    app: httpbin
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: httpbin
spec:
  replicas: 1
  selector:
    matchLabels:
      app: httpbin
      version: v1
  template:
    metadata:
      labels:
        app: httpbin
        version: v1
    spec:
      containers:
        - image: docker.io/kong/httpbin
          imagePullPolicy: IfNotPresent
          name: httpbin
          command:
            - gunicorn
            - -b
            - 0.0.0.0:8080
            - httpbin:app
            - -k
            - gevent
          env:
            - name: WORKON_HOME
              value: /tmp
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: helloworld
  labels:
    app: helloworld
    service: helloworld
spec:
  ports:
    - port: 5000
      name: http
  selector:
    app: helloworld
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: helloworld-v1
  labels:
    app: helloworld
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: helloworld
      version: v1
  template:
    metadata:
      labels:
        app: helloworld
        version: v1
    spec:
      containers:
        - name: helloworld
          image: docker.io/istio/examples-helloworld-v1
          resources:
            requests:
              cpu: "100m"
          imagePullPolicy: IfNotPresent #Always
          ports:
            - containerPort: 5000
EOF
```

> - [httpbin](https://httpbin.org/)是内嵌多个接口，用来测试HTTP请求和调试的服务。
> - `helloworld`用来返回当前处理的pod名称和版本号。

###  配置网关和虚拟服务

```bash
$ cat <<EOF | kubectl -n test apply -f -
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: custom-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 443
        name: https
        protocol: HTTPS
      tls:
        mode: SIMPLE 
        credentialName: httpbin-secret
      hosts:
        - "httpbin.example.com"
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
        - "httpbin.example.com"
---
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: custom-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 443
        name: https-httpbin
        protocol: HTTPS
      tls:
        mode: SIMPLE
        credentialName: httpbin-secret
      hosts:
        - "httpbin.example.com"
    - port:
        number: 443
        name: https-helloworld
        protocol: HTTPS
      tls:
        mode: SIMPLE
        credentialName: helloworld-secret
      hosts:
        - "helloworld.example.com"
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
        - "httpbin.example.com"
---
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: httpbin
spec:
  hosts:
    - "httpbin.example.com"
  gateways:
    - custom-gateway
  http:
    - match:
        - uri:
            prefix: /status
        - uri:
            prefix: /delay
        - uri:
            prefix: /ip
      route:
        - destination:
            port:
              number: 80
            host: httpbin
---
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: helloworld
spec:
  hosts:
    - "helloworld.example.com"
  gateways:
    - custom-gateway
  http:
    - match:
        - uri:
            exact: /hello
      route:
        - destination:
            port:
              number: 5000
            host: helloworld
EOF
```

> - TLS证书默认在`istio-system`命令空间下寻找（改成其他ns即使使用`ns/secret-name`仍会出现无法访问的情况，暂未找到原因）。
>
> - gateway和virtualService通过hosts和gateways字段绑定。
> - gateway中支持不同的域名监听相同的端口，但需定义不同的name用于区分。
> - 不同的域名，最好由不同的`virtualService`分开管理，若不同文件出现相同域名时，按照`文件名字母排序`合并规则，前面的会被覆盖。

###  测试

```bash
# 基于http访问网关
$ curl --resolve "httpbin.example.com:$INGRESS_PORT:$INGRESS_HOST" "http://httpbin.example.com:$INGRESS_PORT/status/418"
# 基于https访问网关
$ curl --resolve "httpbin.example.com:$SECURE_INGRESS_PORT:$INGRESS_HOST" --cacert example_certs1/example.com.crt "https://httpbin.example.com:$SECURE_INGRESS_PORT/status/418"
# 基于https访问helloworld.example.com
$ curl --resolve "helloworld.example.com:$SECURE_INGRESS_PORT:$INGRESS_HOST" "http://helloworld.example.com:$SECURE_INGRESS_PORT/hello"
# 返回如下即为成功
    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
```

> 1. --resolve用于执行DNS解析，避免修改/etc/hosts
> 2. --cacert用于https访问时指定CA证书的地址用于验证，可以不指定，使用`-k`跳过证书验证。
> 2. 通过`kubectl -n istio-system get po -l istio=ingressgateway  | awk 'NR == 2{print $1}' | xargs istioctl proxy-config listener -n istio-system`查看当前Envoy的代理情况
>
> ```bash
> ADDRESSES PORT  MATCH                    DESTINATION
> 0.0.0.0   8080  ALL                      Route: http.8080
> 0.0.0.0   8443  SNI: httpbin.example.com Cluster: outbound|443||nginx-service.test.svc.cluster.local
> 0.0.0.0   15021 ALL                      Inline Route: /healthz/ready*
> 0.0.0.0   15090 ALL                      Inline Route: /stats/prometheus*
> ```
>
> SNI（Server Name Indication）是一种在TLS和SSL协议中的扩展，用于在`单个IP地址上支持多个域名的加密通信`。在没有SNI的情况下，一个IP地址只能关联一个SSL/TLS证书，因此只能支持一个域名。有了SNI，服务器可以根据客户端请求的域名动态选择相应的证书进行通信。

##  TLS双向网关

> 双向TLS，它在通信的两端都使用证书进行身份验证，确保通信的安全性。双向TLS也被称为`客户端身份验证`，因为在传统的单向TLS中，只有服务器需要提供证书进行身份验证，而客户端则不需要。[> 详情点击](https://help.aliyun.com/zh/api-gateway/user-guide/mutual-tls-authentication)

```bash
# 生成证书Secret
$ kubectl create -n istio-system secret generic httpbin-mutual-secret \
  --from-file=tls.key=example_certs1/httpbin.example.com.key \
  --from-file=tls.crt=example_certs1/httpbin.example.com.crt \
  --from-file=ca.crt=example_certs1/example.com.crt
```

> 服务器使用CA证书来验证其客户端，我们必须使用名称`ca.crt`来持有 CA 证书。

###  配置网关和虚拟服务

```bash
$ cat <<EOF | kubectl -n test apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: manual-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: MUTUAL # 表示双向TLS
      credentialName: httpbin-mutual-secret
    hosts:
    - httpbin.example.com
---
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: manual-httpbin
spec:
  hosts:
    - "httpbin.example.com"
  gateways:
    - manual-gateway
  http:
    - match:
        - uri:
            prefix: /status
        - uri:
            prefix: /delay
        - uri:
            prefix: /ip
      route:
        - destination:
            port:
              number: 80
            host: httpbin
EOF
```

###  测试

```bash
$ curl --resolve "httpbin.example.com:$SECURE_INGRESS_PORT:$INGRESS_HOST" \
--cacert example_certs1/example.com.crt \
--cert example_certs1/client.example.com.crt \
--key example_certs1/client.example.com.key \
"https://httpbin.example.com:$SECURE_INGRESS_PORT/status/418"
```

> 自签证书必须要指定client证书的位置。

##  TLS透传网关

> 通常用于`直接将TLS流量传递给后端服务`，而不在istio中进行解密。这种模式提供了一种`端到端`的加密传输方式，使istio不参与到TLS握手的解密和再加密过程中。

###  生成证书凭证

```bash
$ kubectl -n test create configmap nginx-tls-config \
--from-file=tls.crt=example_certs1/httpbin.example.com.crt \
--from-file=tls.key=example_certs1/httpbin.example.com.key
```

###  配置服务和Service

```bash
$ cat <<EOF | kubectl -n test apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  default.conf: |
    server {
      listen 80;
      server_name httpbin.example.com;
  
      location / {
          root /usr/share/nginx/html;
          index index.html;
      }
    }
    server {
      listen 443 ssl;
      server_name httpbin.example.com;

      ssl_certificate /etc/nginx/certs/tls.crt;
      ssl_certificate_key /etc/nginx/certs/tls.key;
      location / {
          root /usr/share/nginx/html;
          index index.html;
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80
            - containerPort: 443
          volumeMounts:
            - name: nginx-tls
              mountPath: "/etc/nginx/certs"
              readOnly: true
            - name: nginx-config
              mountPath: "/etc/nginx/conf.d"
              readOnly: true
      volumes:
        - name: nginx-tls
          configMap:
            name: nginx-tls-config
        - name: nginx-config
          configMap:
            name: nginx-config
            items:
              - key: default.conf
                path: default.conf
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      name: http
      port: 80
      targetPort: 80
    - protocol: TCP
      name: https
      port: 443
      targetPort: 443
  type: ClusterIP
EOF
```

###  配置网关和虚拟服务

```bash
$ cat <<EOF | kubectl -n test apply -f -
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: paasthrough-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 443
        name: https-httpbin
        protocol: TLS # 不是HTTPS
      tls:
        mode: PASSTHROUGH # tls类型为PASSTHROUGH
      hosts:
        - "httpbin.example.com"
    - port:
        number: 80
        name: http-httpbin
        protocol: HTTP
      hosts:
        - "httpbin.example.com"
---
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: paasthrough-httpbin
spec:
  hosts:
    - "httpbin.example.com"
  gateways:
    - paasthrough-gateway
  tls: # 与protocol一致
    - match:
        - port: 443
          sniHosts:
            - "httpbin.example.com"
      route:
        - destination:
            host: nginx-service
            port:
              number: 443
  http:
    - match:
        - port: 80
      route:
        - destination:
            host: nginx-service
            port:
              number: 80
EOF
```

###  测试

```bash
# 基于http访问
$ curl --resolve "httpbin.example.com:$INGRESS_PORT:$INGRESS_HOST" "http://httpbin.example.com:$INGRESS_PORT"
# 基于https访问
$ curl --resolve "httpbin.example.com:$SECURE_INGRESS_PORT:$INGRESS_HOST" --cacert example_certs1/example.com.crt "https://httpbin.example.com:$SECURE_INGRESS_PORT"
```

---
